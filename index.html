<!DOCTYPE html>
<html>
<head>
    <title>Solitaire</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
body {
    margin: 0;
    padding: 0;
}

#game-container {
    width: 800px;
    margin: 0 auto;
}

#buttons {
    margin: 10px;
    text-align: center;
}

#new-game-button, #solve-button {
    padding: 10px 20px;
    font-size: 16px;
    background-color: #4CAF50; /* Green background */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin: 0 5px; /* Space between buttons */
}

#new-game-button:hover, #solve-button:hover {
    background-color: #45a049; /* Darker green on hover */
}

#solve-button:disabled, #new-game-button:disabled {
    background-color: #cccccc; /* Gray when disabled */
    cursor: not-allowed;
}

    </style>
</head>
<body>
    <div id="game-container">
        <div id="buttons">
            <button id="new-game-button">New Game</button>
            <button id="solve-button" disabled>Solve</button>
        </div>
        <div id="canvas-container"></div>
    </div>
    <div id="canvas-container"></div>
    <script>

// Constants for card dimensions and game layout
const CARD_SPACING = 15;
const MARGIN = 15;
const CARD_COLOR = '#fff';
const TABLE_COLOR = '#008000';
const BORDER_RADIUS = 8;
const DOUBLE_CLICK_DELAY = 300; // milliseconds
const SOLVE_SPEED = 10; // pixels per frame for animation
const SUITS = ['♠', '♥', '♦', '♣'];
const suitToRow = {
    '♦': 0,  // Diamonds -> row 0
    '♥': 1,  // Hearts   -> row 1
    '♠': 2,  // Spades   -> row 2
    '♣': 3   // Clubs    -> row 3
};
const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
const CARD_WIDTH = 100;  // Canvas width, adjust as needed
const CARD_HEIGHT = 142; // Canvas height, adjust as needed

// --- Animation Constants ---
const NEW_GAME_ANIM_SPEED = 0.04; // SLOWER: Animation speed factor (0 to 1)
let STACK_X; // Center X for stacking (defined in setup)
let STACK_Y; // Center Y for stacking (defined in setup)
const FLIGHT_ROTATION_AMOUNT = Math.PI * 1.5; // Max rotation during flight (radians)
const STACK_OFFSET_AMOUNT = 0.2; // How much cards are offset in the stack visually


// Game state variables
let deck = [];
let stock = [];
let waste = [];
let foundations = [[], [], [], []];
let tableau = [[], [], [], [], [], [], []];
let selectedCard = null;
let draggingStack = [];
let dragOffset = { x: 0, y: 0 };
let dragSource = null;
let gameResult = ''; // 'win' or 'lose' or 'stuck'
let isDragging = false;
let lastClickTime = 0;
let lastClickedCard = null;

// Variables for solving animation
let isSolving = false;
let solvingCard = null;
let targetX, targetY;
let solvingFoundationIndex;

// Variables for New Game Animation
let isAnimatingNewGame = false;
let animationPhase = 'none'; // 'none', 'flying_to_stack', 'dealing_from_stack'
let allCardsForAnimation = [];
let animationProgress = 0; // Progress for the current phase (0 to 1)
let canvas; // Reference to the p5 canvas

// Add global variable for the card image
let cardsImg;

// Preload the card image
function preload() {
    cardsImg = loadImage('https://vita2048.github.io/Solitaire/Cards.jpg');
}

// Mapping from suit symbols to row indices in the image


// Card class to represent each card
class Card {
    constructor(suit, value, faceUp = false) {
        this.suit = suit;
        this.value = value;
        this.faceUp = faceUp;
        this.x = 0; // Current visual x
        this.y = 0; // Current visual y
        this.color = (this.suit === '♥' || this.suit === '♦') ? 'red' : 'black';

        // Animation properties
        this.animStartX = 0;
        this.animStartY = 0;
        this.animTargetX = 0;
        this.animTargetY = 0;
        this.animRotation = 0; // Current visual rotation
        this.animStartRotation = 0;
        this.animTargetRotation = 0;
        this.finalGameX = 0; // Store the final game position
        this.finalGameY = 0;
        this.stackOrder = 0; // Used for slight offset in stack
    }

    // Modified draw method to use card images
    draw() {
        push(); // Isolate transformations
        translate(this.x + CARD_WIDTH / 2, this.y + CARD_HEIGHT / 2); // Move origin to card center
        rotate(this.animRotation); // Apply current animated rotation
        translate(-CARD_WIDTH / 2, -CARD_HEIGHT / 2); // Move origin back

        if (this.faceUp || isAnimatingNewGame) {
            // Calculate the source coordinates in the image
			let row = suitToRow[this.suit];
			let rankIndex = VALUES.indexOf(this.value); // 0 for 'A', 12 for 'K'
			let column = 12 - rankIndex; // Reverse: 'K' to column 0, 'A' to column 12
			let sx = 195 + column * 382;
			let sy = 451 + row * 719;
			image(cardsImg, 0, 0, CARD_WIDTH, CARD_HEIGHT, sx, sy, 348, 497);
        } else {
            // Draw card back (unchanged)
            fill(85, 107, 47); // Dark green
            stroke(0);
            strokeWeight(1);
            rect(0, 0, CARD_WIDTH, CARD_HEIGHT, BORDER_RADIUS);

            // Simple pattern for card back
            stroke(255, 255, 255, 100);
            for (let i = 10; i < CARD_WIDTH; i += 10) {
                line(i, 10, i, CARD_HEIGHT - 10);
            }
            for (let i = 10; i < CARD_HEIGHT; i += 10) {
                line(10, i, CARD_WIDTH - 10, i);
            }
        }
        pop(); // Restore transformations
    }

    containsPoint(px, py) {
        // Simple bounding box check (ignores rotation for clicking efficiency)
        return px >= this.x && px <= this.x + CARD_WIDTH &&
               py >= this.y && py <= this.y + CARD_HEIGHT;
    }

    clone() {
        const card = new Card(this.suit, this.value, this.faceUp);
        card.x = this.x;
        card.y = this.y;
        card.finalGameX = this.finalGameX;
        card.finalGameY = this.finalGameY;
        return card;
    }

    updateAnimation() {
        const smoothProgress = (1 - cos(animationProgress * PI)) / 2;
        this.x = lerp(this.animStartX, this.animTargetX, smoothProgress);
        this.y = lerp(this.animStartY, this.animTargetY, smoothProgress);
        this.animRotation = lerp(this.animStartRotation, this.animTargetRotation, smoothProgress);
    }
}

// The rest of the code (setup, draw, and all other functions) remains unchanged
function setup() {
    canvas = createCanvas(820, 600);
    canvas.parent('canvas-container');
    textFont('Arial');

    STACK_X = width / 2 - CARD_WIDTH / 2;
    STACK_Y = height / 2 - CARD_HEIGHT / 2;

    const newGameButton = select('#new-game-button');
    if (newGameButton) {
        newGameButton.mousePressed(triggerNewGameAnimation);
    } else {
        console.error("New Game button not found!");
    }

    const solveButton = select('#solve-button');
    if (solveButton) {
        solveButton.mousePressed(() => {
            gameResult = '';
            isSolving = true;
        });
    } else {
        console.error("Solve button not found!");
    }

    startNewGame(false);
}

function draw() {
    background(TABLE_COLOR);

    if (isAnimatingNewGame) {
        animateNewGame();
        return;
    }

    drawPlaceholders();
    drawStock();
    drawWaste();
    drawFoundations();
    drawTableau();

    if (isDragging && draggingStack.length > 0) {
        for (let i = 0; i < draggingStack.length; i++) {
            const card = draggingStack[i];
            const drawX = mouseX - dragOffset.x;
            const drawY = mouseY - dragOffset.y + i * 20;
            drawCardAt(card, drawX, drawY);
        }
    }

    if (solvingCard) {
        solvingCard.draw();
    }

    const solveButton = select('#solve-button');
    if (solveButton) {
        const canSolve = !gameResult && stock.length === 0 && waste.length === 0 && allTableauCardsFaceUp();
        solveButton.elt.disabled = !canSolve;
    }

    if (gameResult) {
        drawGameResult();
    }

    if (isSolving) {
        updateSolvingAnimation();
    }
}

function drawCardAt(card, x, y) {
    const originalX = card.x;
    const originalY = card.y;
    const originalRot = card.animRotation;
    card.x = x;
    card.y = y;
    card.animRotation = 0;
    card.draw();
    card.x = originalX;
    card.y = originalY;
    card.animRotation = originalRot;
}

function triggerNewGameAnimation() {
    if (isAnimatingNewGame) return;

    isAnimatingNewGame = true;
    animationPhase = 'flying_to_stack';
    animationProgress = 0;
    gameResult = '';
    isSolving = false;
    solvingCard = null;

    allCardsForAnimation = [];
    stock.forEach(card => allCardsForAnimation.push(card));
    waste.forEach(card => allCardsForAnimation.push(card));
    foundations.forEach(pile => pile.forEach(card => allCardsForAnimation.push(card)));
    tableau.forEach(pile => pile.forEach(card => allCardsForAnimation.push(card)));

    if (allCardsForAnimation.length !== 52) {
        console.warn("Card count mismatch before animation:", allCardsForAnimation.length);
        allCardsForAnimation = [];
        for (let suit of SUITS) {
            for (let value of VALUES) {
                allCardsForAnimation.push(new Card(suit, value, true));
            }
        }
        allCardsForAnimation.forEach(card => {
            card.x = MARGIN; card.y = MARGIN;
        });
    }

    allCardsForAnimation.forEach((card, index) => {
        card.animStartX = card.x;
        card.animStartY = card.y;
        card.animStartRotation = card.animRotation;

        card.stackOrder = index;
        card.animTargetX = STACK_X + (index - 26) * STACK_OFFSET_AMOUNT;
        card.animTargetY = STACK_Y + (index - 26) * STACK_OFFSET_AMOUNT;
        card.animTargetRotation = random(-FLIGHT_ROTATION_AMOUNT, FLIGHT_ROTATION_AMOUNT);

        card.faceUp = true;
    });

    shuffle(allCardsForAnimation, true);

    stock = [];
    waste = [];
    foundations = [[], [], [], []];
    tableau = [[], [], [], [], [], [], []];
}

function animateNewGame() {
    background(TABLE_COLOR);

    animationProgress += NEW_GAME_ANIM_SPEED;
    animationProgress = min(animationProgress, 1);

    allCardsForAnimation.forEach(card => {
        card.updateAnimation();
        card.draw();
    });

    if (animationProgress >= 1) {
        if (animationPhase === 'flying_to_stack') {
            animationPhase = 'dealing_from_stack';
            animationProgress = 0;

            startNewGame(true);

            allCardsForAnimation.forEach(card => {
                card.animStartX = card.x;
                card.animStartY = card.y;
                card.animStartRotation = card.animRotation;

                card.animTargetX = card.finalGameX;
                card.animTargetY = card.finalGameY;
                card.animTargetRotation = 0;
            });
        } else if (animationPhase === 'dealing_from_stack') {
            isAnimatingNewGame = false;
            animationPhase = 'none';
            finalizeNewGameState();
        }
    }
}

function finalizeNewGameState() {
    allCardsForAnimation.forEach(card => {
        card.x = card.finalGameX;
        card.y = card.finalGameY;
        card.animRotation = 0;
    });

    stock.forEach(card => card.faceUp = false);
    waste.forEach(card => card.faceUp = true);
    for(let i = 0; i < 7; i++) {
        if (tableau[i].length > 0) {
            tableau[i].forEach((card, j) => {
                card.faceUp = (j === tableau[i].length - 1);
            });
        }
    }
    foundations.forEach(pile => pile.forEach(card => card.faceUp = true));

    allCardsForAnimation = [];
}

function drawPlaceholders() {
    fill(16, 74, 28, 150);
    noStroke();

    rect(MARGIN, MARGIN, CARD_WIDTH, CARD_HEIGHT, BORDER_RADIUS);
    rect(MARGIN + CARD_WIDTH + CARD_SPACING, MARGIN, CARD_WIDTH, CARD_HEIGHT, BORDER_RADIUS);
    for (let i = 0; i < 4; i++) {
        rect(MARGIN + (i + 3) * (CARD_WIDTH + CARD_SPACING), MARGIN, CARD_WIDTH, CARD_HEIGHT, BORDER_RADIUS);
    }
    for (let i = 0; i < 7; i++) {
        rect(MARGIN + i * (CARD_WIDTH + CARD_SPACING), MARGIN + CARD_HEIGHT + CARD_SPACING, CARD_WIDTH, CARD_HEIGHT, BORDER_RADIUS);
    }
    stroke(0);
}

function drawStock() {
    if (stock.length > 0) {
        const card = stock[stock.length - 1];
        card.x = MARGIN;
        card.y = MARGIN;
        if (!isAnimatingNewGame) card.draw();
    }
}

function drawWaste() {
    if (waste.length > 0 && !isCardBeingDragged(waste[waste.length - 1])) {
        const card = waste[waste.length - 1];
        card.x = MARGIN + CARD_WIDTH + CARD_SPACING;
        card.y = MARGIN;
        if (!isAnimatingNewGame) card.draw();
    }
}

function drawFoundations() {
    for (let i = 0; i < 4; i++) {
        if (foundations[i].length > 0 && !isCardBeingDragged(foundations[i][foundations[i].length - 1])) {
            const card = foundations[i][foundations[i].length - 1];
            card.x = MARGIN + (i + 3) * (CARD_WIDTH + CARD_SPACING);
            card.y = MARGIN;
            if (!isAnimatingNewGame) card.draw();
        }
    }
}

function drawTableau() {
    for (let i = 0; i < 7; i++) {
        for (let j = 0; j < tableau[i].length; j++) {
            const card = tableau[i][j];
            card.x = MARGIN + i * (CARD_WIDTH + CARD_SPACING);
            card.y = MARGIN + CARD_HEIGHT + CARD_SPACING + j * 20;
            if (!isAnimatingNewGame && !isCardBeingDragged(card)) {
                card.draw();
            }
        }
    }
}

function isCardBeingDragged(card) {
    return isDragging && draggingStack.includes(card);
}

function drawGameResult() {
    fill(0, 0, 0, 200);
    rect(0, height / 2 - 50, width, 100);

    fill(255);
    textAlign(CENTER, CENTER);
    textSize(32);
    text(gameResult === 'win' ? 'Congratulations! You Win!' : (gameResult === 'stuck' ? 'No more moves!' : 'Game Over'), width / 2, height / 2);
}

function startNewGame(isCalledForAnimation = false) {
    gameResult = '';
    isSolving = false;
    solvingCard = null;

    let deckToUse;
    if (isCalledForAnimation) {
        deckToUse = [...allCardsForAnimation];
        for (let i = deckToUse.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deckToUse[i], deckToUse[j]] = [deckToUse[j], deckToUse[i]];
        }
    } else {
        deck = [];
        for (let suit of SUITS) {
            for (let value of VALUES) {
                deck.push(new Card(suit, value));
            }
        }
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        deckToUse = deck;
    }

    stock = [];
    waste = [];
    foundations = [[], [], [], []];
    tableau = [[], [], [], [], [], [], []];

    stock = [...deckToUse];

    for (let i = 0; i < 7; i++) {
        for (let j = 0; j <= i; j++) {
            if (stock.length === 0) break;
            const card = stock.pop();
            card.faceUp = (j === i);
            tableau[i].push(card);
        }
    }

    stock.forEach((card) => {
        const finalX = MARGIN;
        const finalY = MARGIN;
        if (isCalledForAnimation) {
            card.finalGameX = finalX;
            card.finalGameY = finalY;
        } else {
            card.x = finalX;
            card.y = finalY;
            card.faceUp = false;
        }
    });

    for (let i = 0; i < 7; i++) {
        for (let j = 0; j < tableau[i].length; j++) {
            const card = tableau[i][j];
            const finalX = MARGIN + i * (CARD_WIDTH + CARD_SPACING);
            const finalY = MARGIN + CARD_HEIGHT + CARD_SPACING + j * 20;
            const isFaceUp = (j === tableau[i].length - 1);

            if (isCalledForAnimation) {
                card.finalGameX = finalX;
                card.finalGameY = finalY;
            } else {
                card.x = finalX;
                card.y = finalY;
                card.faceUp = isFaceUp;
            }
        }
    }
}

function updateSolvingAnimation() {
    if (isSolving && solvingCard === null) {
        const movable = findMovableCard();
        if (movable) {
            const { card, foundationIndex, sourcePile } = movable;

            if(sourcePile === waste){
                waste.pop();
            } else if (tableau.includes(sourcePile)){
                sourcePile.pop();
                if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                    sourcePile[sourcePile.length - 1].faceUp = true;
                }
            } else if (foundations.includes(sourcePile)){
                console.warn("Solver trying to move card from foundation?");
                isSolving = false;
                return;
            }

            solvingCard = card;
            solvingFoundationIndex = foundationIndex;
            targetX = MARGIN + (foundationIndex + 3) * (CARD_WIDTH + CARD_SPACING);
            targetY = MARGIN;
        } else {
            if (foundations.reduce((sum, f) => sum + f.length, 0) === 52) {
                gameResult = 'win';
            } else {
                gameResult = 'stuck';
            }
            isSolving = false;
        }
    }

    if (solvingCard) {
        let dx = targetX - solvingCard.x;
        let dy = targetY - solvingCard.y;
        let distSq = dx * dx + dy * dy;
        if (distSq < SOLVE_SPEED * SOLVE_SPEED) {
            solvingCard.x = targetX;
            solvingCard.y = targetY;
            foundations[solvingFoundationIndex].push(solvingCard);
            solvingCard.faceUp = true;
            solvingCard = null;
            checkWinCondition();
        } else {
            let dist = sqrt(distSq);
            solvingCard.x += (dx / dist) * SOLVE_SPEED;
            solvingCard.y += (dy / dist) * SOLVE_SPEED;
        }
    }
}

function mousePressed() {
    if (isSolving || isAnimatingNewGame) return;

    const currentTime = millis();
    const timeSinceLastClick = currentTime - lastClickTime;
    let clickedCardInfo = findClickedCard(mouseX, mouseY);

    if (clickedCardInfo && clickedCardInfo.card.faceUp && lastClickedCard === clickedCardInfo.card && timeSinceLastClick < DOUBLE_CLICK_DELAY) {
        let sourcePile = clickedCardInfo.source;
        let isTopCard = false;
        if(sourcePile === waste && sourcePile.length > 0 && sourcePile[sourcePile.length - 1] === clickedCardInfo.card) isTopCard = true;
        if(tableau.includes(sourcePile) && sourcePile.length > 0 && sourcePile[sourcePile.length - 1] === clickedCardInfo.card) isTopCard = true;

        if (isTopCard && attemptMoveToFoundation(clickedCardInfo.card, sourcePile)) {
            lastClickedCard = null;
            return;
        }
    }

    lastClickTime = currentTime;
    lastClickedCard = clickedCardInfo ? clickedCardInfo.card : null;

    const stockX = MARGIN; const stockY = MARGIN;
    if (mouseX >= stockX && mouseX <= stockX + CARD_WIDTH && mouseY >= stockY && mouseY <= stockY + CARD_HEIGHT) {
        if (stock.length > 0) {
            const card = stock.pop();
            card.faceUp = true;
            waste.push(card);
            return;
        } else if (waste.length > 0) {
            while (waste.length > 0) {
                const card = waste.pop();
                card.faceUp = false;
                stock.push(card);
            }
            return;
        }
    }

    if (clickedCardInfo && clickedCardInfo.card.faceUp) {
        selectedCard = clickedCardInfo.card;
        dragSource = clickedCardInfo.source;
        isDragging = true;
        dragOffset.x = mouseX - selectedCard.x;
        dragOffset.y = mouseY - selectedCard.y;

        if (tableau.includes(dragSource)) {
            const cardIndex = dragSource.indexOf(selectedCard);
            draggingStack = dragSource.slice(cardIndex);
        } else if (dragSource === waste && waste.length > 0 && waste[waste.length - 1] === selectedCard) {
            draggingStack = [selectedCard];
        } else if (foundations.includes(dragSource) && dragSource.length > 0 && dragSource[dragSource.length - 1] === selectedCard) {
            draggingStack = [selectedCard];
        } else {
            draggingStack = [];
            isDragging = false;
            selectedCard = null;
        }
    } else {
        selectedCard = null;
        draggingStack = [];
        isDragging = false;
    }
}

function findClickedCard(px, py) {
    if (waste.length > 0) {
        const card = waste[waste.length - 1];
        const wx = MARGIN + CARD_WIDTH + CARD_SPACING;
        const wy = MARGIN;
        if (px >= wx && px <= wx + CARD_WIDTH && py >= wy && py <= wy + CARD_HEIGHT) {
            return { card: card, source: waste };
        }
    }

    for (let i = 0; i < 4; i++) {
        if (foundations[i].length > 0) {
            const card = foundations[i][foundations[i].length - 1];
            const fx = MARGIN + (i + 3) * (CARD_WIDTH + CARD_SPACING);
            const fy = MARGIN;
            if (px >= fx && px <= fx + CARD_WIDTH && py >= fy && py <= fy + CARD_HEIGHT) {
                return { card: card, source: foundations[i] };
            }
        }
    }

    for (let i = 6; i >= 0; i--) {
        for (let j = tableau[i].length - 1; j >= 0; j--) {
            const card = tableau[i][j];
            const tpx = MARGIN + i * (CARD_WIDTH + CARD_SPACING);
            const tpy = MARGIN + CARD_HEIGHT + CARD_SPACING + j * 20;
            const cardEndY = tpy + (j === tableau[i].length - 1 ? CARD_HEIGHT : 20);

            if (px >= tpx && px <= tpx + CARD_WIDTH && py >= tpy && py <= cardEndY) {
                if (card.faceUp) {
                    return { card: card, source: tableau[i] };
                } else {
                    break;
                }
            }
        }
    }

    return null;
}

function attemptMoveToFoundation(card, source) {
    for (let i = 0; i < 4; i++) {
        if (canMoveToFoundation(card, i)) {
            if (source === waste) {
                waste.pop();
            } else if (tableau.includes(source)) {
                source.pop();
                if (source.length > 0 && !source[source.length - 1].faceUp) {
                    source[source.length - 1].faceUp = true;
                }
            } else {
                return false;
            }

            foundations[i].push(card);
            card.faceUp = true;
            checkWinCondition();
            return true;
        }
    }
    return false;
}

function canMoveToFoundation(card, foundationIndex) {
    const foundation = foundations[foundationIndex];
    if (foundation.length === 0) {
        return card.value === 'A';
    } else {
        const topCard = foundation[foundation.length - 1];
        const nextValueIndex = VALUES.indexOf(topCard.value) + 1;
        return card.suit === topCard.suit &&
               nextValueIndex < VALUES.length &&
               card.value === VALUES[nextValueIndex];
    }
}

function canMoveToTableau(card, tableauPileIndex) {
    const pile = tableau[tableauPileIndex];
    if (pile.length === 0) {
        return card.value === 'K';
    } else {
        const topCard = pile[pile.length - 1];
        if (!topCard.faceUp) return false;

        const targetValueIndex = VALUES.indexOf(topCard.value);
        const sourceValueIndex = VALUES.indexOf(card.value);

        return card.color !== topCard.color && sourceValueIndex === targetValueIndex - 1;
    }
}

function checkWinCondition() {
    if (foundations.reduce((sum, f) => sum + f.length, 0) === 52) {
        gameResult = 'win';
        isSolving = false;
    }
}

function mouseReleased() {
    if (isSolving || isAnimatingNewGame || !isDragging || draggingStack.length === 0) {
        isDragging = false;
        draggingStack = [];
        return;
    }

    const cardToDrop = draggingStack[0];
    let moveSuccessful = false;

    if (draggingStack.length === 1) {
        for (let i = 0; i < 4; i++) {
            const fx = MARGIN + (i + 3) * (CARD_WIDTH + CARD_SPACING);
            const fy = MARGIN;
            if (mouseX >= fx && mouseX <= fx + CARD_WIDTH && mouseY >= fy && mouseY <= fy + CARD_HEIGHT) {
                if (canMoveToFoundation(cardToDrop, i)) {
                    if (dragSource === waste) waste.pop();
                    else if (foundations.includes(dragSource)) dragSource.pop();
                    else if (tableau.includes(dragSource)) {
                        dragSource.pop();
                        if (dragSource.length > 0 && !dragSource[dragSource.length - 1].faceUp) {
                            dragSource[dragSource.length - 1].faceUp = true;
                        }
                    }
                    foundations[i].push(cardToDrop);
                    cardToDrop.faceUp = true;
                    checkWinCondition();
                    moveSuccessful = true;
                    break;
                }
            }
        }
    }

    if (!moveSuccessful) {
        for (let i = 0; i < 7; i++) {
            const tx = MARGIN + i * (CARD_WIDTH + CARD_SPACING);
            const pile = tableau[i];
            const targetY = MARGIN + CARD_HEIGHT + CARD_SPACING + max(0, (pile.length - 1)) * 20;
            const targetHeight = pile.length === 0 ? CARD_HEIGHT : CARD_HEIGHT + 20;

            if (mouseX >= tx && mouseX <= tx + CARD_WIDTH && mouseY >= targetY && mouseY <= targetY + targetHeight) {
                if (canMoveToTableau(cardToDrop, i)) {
                    if (dragSource === waste) waste.pop();
                    else if (foundations.includes(dragSource)) dragSource.pop();
                    else if (tableau.includes(dragSource)) {
                        const startIndex = dragSource.indexOf(cardToDrop);
                        dragSource.splice(startIndex, draggingStack.length);
                        if (dragSource.length > 0 && !dragSource[dragSource.length - 1].faceUp) {
                            dragSource[dragSource.length - 1].faceUp = true;
                        }
                    }
                    draggingStack.forEach(card => tableau[i].push(card));
                    moveSuccessful = true;
                    break;
                }
            }
        }
    }

    selectedCard = null;
    draggingStack = [];
    dragSource = null;
    isDragging = false;
}

function keyPressed() {
    if (isAnimatingNewGame) return;

    if (key === 'n' || key === 'N') {
        triggerNewGameAnimation();
    }
    if (key === 's' || key === 'S') {
        if (!gameResult && stock.length === 0 && waste.length === 0 && allTableauCardsFaceUp()) {
            gameResult = '';
            isSolving = true;
        }
    }
}

function allTableauCardsFaceUp() {
    return tableau.every(pile => pile.every(card => card.faceUp));
}

function findMovableCard() {
    if(waste.length > 0) {
        const card = waste[waste.length - 1];
        for (let j = 0; j < 4; j++) {
            if (canMoveToFoundation(card, j)) {
                return { card, foundationIndex: j, sourcePile: waste };
            }
        }
    }
    for (let i = 0; i < 7; i++) {
        if (tableau[i].length > 0) {
            const card = tableau[i][tableau[i].length - 1];
            if (card.faceUp) {
                for (let j = 0; j < 4; j++) {
                    if (canMoveToFoundation(card, j)) {
                        return { card, foundationIndex: j, sourcePile: tableau[i] };
                    }
                }
            }
        }
    }
    return null;
}
</script>
    </script>
</body>
</html>
